alright so last year what when we talk about hazards and you know there are two types of hazards right latent dependency hazards which is what you try to take care of by your data tagging internal body and the other type of hazards are job scheduling hazards and that's where we talk about collisions in the use of reservant table to prevent them just one point the ladies brought up to my attention when we talk about order table co-ording mechanisms to be very strict about it if you want to say that this after all the ording mechanism that you use produces an end state that is identical to the original sequence of instructions then we really need to have this as well in another word or rather make he make it uh comes up like that alright to be strict about it okay because the state of a system the state of a machine is determined by the contents of the internal registers alright at the end of this original set of instructions when mister ro would contain the result of that multiplication alright and that same result is word  into memory but it still contain in ro after that copy of registers alright for that year at the end of it ro will also should also contain the result of that multiplication alright so that's latent depend dependency has okay then we started on job scheduling hazards and we define a word alright to simplify matters we talk about a unifunction pipeline okay you can do likewise or multifunction pipelines too but it's more complicated you know initiation is just referring to the starting of a job in the pipeline and the job scheduling hazard essentially refers to a collision when more than one job try to use a particular stage of the pipeline and we need to use the reservation table to help us prevent collisions between jobs alright the latency in time interval between successive initiations that means between successive jobs a latency sequence is just a sequence of just the interval between jobs right and in if that sequence happen of intervals se uhm sequence repeats itself we call it a latency cycle okay alright and i showed you this example of a reservating table and we know that if you try to start a second job one time unit later you will get a collision right here at square two two right because job one is trying to use this stage job two is also trying to use the same stage okay job two is the blue mark job one is a red mark right so we know we need to obtain a set of forbidden latencies that means those tine intervals that we cannot start new jobs alright okay we start new jobs during those intervals at those intervals you will lead to collisions okay and it turns out that forbidden latencies can be easily obtained from the reservation table by taking the distance between marks in any row for this particular case the mark in the rows give us this set forbidden latencies alright one five six and eight okay you have marked it up one square apart here to there is five squares apart from here to here is six squares apart alright and from that to that there are eight squares apart okay so those are the forbidden latencies okay if you start a job at an interval equal to the spacing between any of those two marks then the utilisation of say stage two by the earlier job at the later time and by the later job at the earlier time you will clash what i'm trying to say is this supposing okay here is one two three four five so you start the first job and then you start the second job five times units later alright and at the time when the first job means stage two here that corresponds to a time when the second job meets stage two at this point alright because if you start your second job five times units later it may clash right okay this mark here corresponding to a second job is collision at this point actually isn't it you know you know in its reservation table okay so we know we can get the forbidden latencies right and to make control of the pipeline easier all these collision uhm time intervals the forbidden latencies can be put into what is called a collision vector and a collision vector is simply is single bit positions alright where the bit position equal to a one bit position k equals to a one if k is an element of your forbidden set okay that's a collision vector all other bit position will be a zero so for this specific example then what we are going to have for the collision vector is position one two three four five six seven eight that's the collision vector for this example alright position counting from right hand side starting at one okay so bit k is a one in k itself is in your forbidden latency and we make use of the shift register to decide when we can start a new job and you make use of it this way when we start a job in the pipeline you would load this vector into a shift register okay this collision vector goes into a shift register i mean start the job alright and then we start shifting one bit at a time for each clock cycle if you shift a one out then if that at that instant you cannot start a new job alright if you shift a zero out then you can start a new job okay now we said over here forbidden latencies are one five six eight so your first after you have started a new job you loaded this in the next clock cycle you will shift a one out that way you cannot start at the next clock cycle alright second clock cycle later you're shifting the zero out you can start a new job at the second clock cycle alright and that will not lead to a collision right because if you start one clock cycle later you see that collision at square two two if you start two cycles later there's no problem okay no clashes between the red and blue marks right so load this into a shift register and if you shift a one out then you cannot start a new job okay at that time instance right each cycle you shift one bit right okay now think of how the state of the pipeline will proceed from here right we've started one job without this okay so we loaded this collision vector one clock cycle later we shifted a one out we cannot start a new job second clock cycle after that you're shifting a zero you know you can start a new job fine and go ahead and start a new job alright if you do that then the new job is going to fit in it's going to start right here right two cycles later and the usage pattern will follow the same as the first one so it will go this way this way that's the second job now we need to know when can we start the third job okay when can we start the third job and so now we have job one and job two in the pipe job one job two okay this initial collision vector was used to prevent collision between this alright supposing after this case if you imagine you have another register okay we have more than one register for this collision vector after the new job we can load this same collision vector into the new register and then we start shifting out from the second register to decide when we start the third job right the situation is exactly the same as between job two and job one right okay between now we're talking about between job three and job two okay so by looking at the second register checking for what is shifted out we can prevent collisions between job three and two but but that's not all that we have to worry about isn't it we need to worry about clashes between job three and one as well alright if you like we can think of it this way we started one job then one time unit passes two time unit passes we started job two right so job two is the one that this collision vector can protect from colliding with job three okay so looking at the second copy of this vector we can prevent collisions between this third job now and the second job that means the blue and the green mark we can prevent clashes using this vector okay we still need to take care of clashes between the third job and whatever is left of the earlier jobs between job three and job one we still need to take care of that between the blue mark and the red mark right now we have not taken care of that yet alright sound complicated but we can just use one register to take care of everything okay because turns out that the convenient technique for handling all of these is to fine we know this which is this same collision vector will protect us from collision between this and this okay now we've started job two two time units later so we've shifted this out and we've shifted that one out so what is left for the first job is this pattern alright we need to or them or this one to this pattern okay so we'll or this and we'll end up with this this becomes the new collision vector and it will protect you against all collisions alright between your new job and all the previous jobs okay because this one prevents collision between three and two that one which is shifted from there prevents collision between the new job and the earlier jobs alright so this becomes the new collision vector for the whole pipeline for the whole system alright and you can proceed to do this for every single interval where you can start new jobs okay we say that this this collision vector represents the state of the pipeline alright and therefore we can obtain what is called a state diagram for the entire pipeline right that tells you exactly at any point in time when you can start another job okay no matter how many other jobs are still in the pipe so we need to get the state diagram alright don't this any more so the initial collision vector is this one two three four five six seven eight i do the working on another sheet alright then this one will give the proper state diagram we cannot start one time unit later we can start a new job two time units later so what is left from here is after two time units later you'll have zero zero one one zero one alright that is what is left from the earlier job for the new job for the second job which is started two time units later we we get this same pattern we or them we end up with this so this becomes the new state of the pipeline alright so we say this is initial alright your first one that comes in and then two time units later we started a new job the new state of the  word of the system becomes characterised by this collision vector alright we can also start a job three time units later right after the first job okay so that will give us a different table okay so that one will give us if you started three time units instead this is what is left again we have to or it  okay what is called the initial collision vector you get another new state okay so this one characterises this system if we started the second job three time units later instead of two so we have this after three time units right and you can proceed on okay second third fourth time interval then we end up with right you again you or them okay to give you the new state you proceed on like that you will end up with this one four units later alright so two three four five six you can start around seven units later if you start one seven units later and you or them you find that you get back this thing itself okay so seven units later you'd get back itself alright because after seven units all you have is a one in the least significant position okay so initial vector all with a one there give you exactly the same thing alright after seven you cannot start one eight units later you can start after nine units ten units eleven units and so on right okay so this also applies for nine and above right after the first clock so right now all we've taken care of is all possibilities after having started one job alright then we go to each of the other and do the same thing okay to find out what other new states so having done all cases with this we come to this so supposing it has first job two time units later it started second job when can we do the third job okay you can't do it one time unit later because you shift a one out you can do it two units later because they're shifting a zero out then you do the same thing right so in that case if you do that you're going to after two units from this state with their two jobs in the system then you start your third job alright we get this okay so that's the new state here where you start another job two units after this state alright again you can go two three four five six you can start one seven units later that will bring you back to this state right so after seven units again you're just left with one at the end okay you or that you have the initial collision vector you get back the same thing okay again you cannot start after eight you can start after nine and above nine and above there's nothing left all you have will be just this so again you have this and nine and above alright so you just proceed the same way for each state that you have not taken care of to fill up to complete this state diagram okay this is called a state diagram so let me just finish this up and one two three four units later you can start one more job right from this state we've taken care of this we've taken care of that okay so four units later and you or the results you're going to end up with this okay so after you you've done this or operation and get the new collision vector you have to check that whatever you have so far to see whether this new vector is in there or not okay whether you need to introduce it as a new state or it's a matter of going back to one of the existing states okay don't repeat the state you're going to confuse yourself alright 